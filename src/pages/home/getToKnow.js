export function renderGetToKnow(container) {
  const section = document.createElement('div')
 section.innerHTML = `
 <section id="get-to-know" class="home-section d-flex justify-content-center flex-column align-items-center">
    <div class="container-fluid p-0">
      <div class="d-flex w-100 align-items-start justify-content-between mb-3">
        <div>
          <h2>Get to Know</h2>
          <p class="mb-0">Short bios, team intros, and ways to connect.</p>
        </div>
        <div class="gtok-controls">
          <button class="btn btn-outline-secondary me-2" data-gtok-prev aria-label="Previous">Prev</button>
          <button class="btn btn-secondary" data-gtok-next aria-label="Next">Next</button>
        </div>
      </div>

      <div class="gtok-carousel">
        <div class="gtok-track">
          <!-- slides generated by JS -->
        </div>
      </div>
    </div>
    </section>
  `
  container.appendChild(section)

  // Build 10 slides
  const track = section.querySelector('.gtok-track')
  const controls = section.querySelector('.gtok-controls')
  const prevBtn = controls.querySelector('[data-gtok-prev]')
  const nextBtn = controls.querySelector('[data-gtok-next]')

  const slides = []
  for (let i = 1; i <= 10; i++) {
    const slide = document.createElement('div')
    slide.className = 'gtok-slide card'
    slide.innerHTML = `
      <div class="card-body d-flex flex-column justify-content-between">
        <header>
          <h5 class="card-title">Person ${i}</h5>
        </header>
        <footer class="mt-3 text-muted small">Role or short footer text for person ${i}</footer>
      </div>
    `
    track.appendChild(slide)
    slides.push(slide)
  }

  // State
  let index = 0
  let slideWidth = 0
  let isDragging = false
  let startX = 0
  let currentTranslate = 0
  let prevTranslate = 0

  function updateSizes() {
    // compute width for each slide (includes gap via CSS)
    if (!slides[0]) return
    slideWidth = slides[0].getBoundingClientRect().width + parseFloat(getComputedStyle(slides[0]).marginRight || '0')
    setPositionByIndex()
  }

  function setPositionByIndex() {
    const maxIndex = Math.max(0, slides.length - visibleCount())
    index = Math.max(0, Math.min(index, maxIndex))
    currentTranslate = -index * slideWidth
    prevTranslate = currentTranslate
    track.style.transform = `translateX(${currentTranslate}px)`
    updateButtons()
  }

  function visibleCount() {
    return window.innerWidth < 768 ? 1 : 5
  }

  function updateButtons() {
    const maxIndex = Math.max(0, slides.length - visibleCount())
    prevBtn.disabled = index <= 0
    nextBtn.disabled = index >= maxIndex
  }

  // Pointer / touch handlers for drag with live movement
  function pointerDown(x) {
    isDragging = true
    startX = x
    track.style.transition = 'none'
  }

  function pointerMove(x) {
    if (!isDragging) return
    const dx = x - startX
    currentTranslate = prevTranslate + dx
    track.style.transform = `translateX(${currentTranslate}px)`
  }

  function pointerUp(x) {
    if (!isDragging) return
    isDragging = false
    const dx = x - startX
    const threshold = Math.max(50, slideWidth * 0.12)
    if (dx > threshold) {
      index = Math.max(0, index - 1)
    } else if (dx < -threshold) {
      index = Math.min(slides.length - visibleCount(), index + 1)
    }
    track.style.transition = ''
    setPositionByIndex()
  }

  // pointer events
  if (window.PointerEvent) {
    track.addEventListener('pointerdown', (e) => { track.setPointerCapture && track.setPointerCapture(e.pointerId); pointerDown(e.clientX) })
    track.addEventListener('pointermove', (e) => pointerMove(e.clientX), { passive: true })
    track.addEventListener('pointerup', (e) => { track.releasePointerCapture && track.releasePointerCapture(e.pointerId); pointerUp(e.clientX) })
    track.addEventListener('pointercancel', () => { isDragging = false })
  } else {
    track.addEventListener('touchstart', (e) => pointerDown(e.touches[0].clientX), { passive: true })
    track.addEventListener('touchmove', (e) => { pointerMove(e.touches[0].clientX); e.preventDefault() }, { passive: false })
    track.addEventListener('touchend', (e) => pointerUp(e.changedTouches[0].clientX), { passive: true })
    // mouse fallback for desktop click-drag
    track.addEventListener('mousedown', (e) => { e.preventDefault(); pointerDown(e.clientX) })
    window.addEventListener('mousemove', (e) => pointerMove(e.clientX))
    window.addEventListener('mouseup', (e) => pointerUp(e.clientX))
  }

  prevBtn.addEventListener('click', () => { index = Math.max(0, index - 1); setPositionByIndex() })
  nextBtn.addEventListener('click', () => { index = Math.min(slides.length - visibleCount(), index + 1); setPositionByIndex() })

  window.addEventListener('resize', () => { updateSizes() })

  // initial layout
  setTimeout(() => { updateSizes(); updateButtons() }, 50)
}
